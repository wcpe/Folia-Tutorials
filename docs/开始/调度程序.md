---
sidebar_position: 4
---

## 使用新的调度程序✨

这些调度程序都有四种方法,`excute`、加上类似`BukkitScheduler`的`runTask`、`runTaskLater`、`runTaskTimer` 。 由于本服务端不存在"异步"，所以没有异步调度的方法。 

由于`excute`返回值为`void`且参数与Bukkit中相似，其余均返回`ScheduledTask`，而且对于手动中止任务等功能的实现较为友好， 所以以下只讲这三种。

### RegionScheduler

这个调度是用于按位置调度的，可以执行该区域相关数据的任务，请不要在这个调度中操作实体，你应该使用`EntityScheduler`，实体调度器会跟随实体一起传送，而区域调度器不会，可能会导致`null`:访问不到`entity`。

```java
ScheduledTask run(Plugin plugin, Location location, Consumer<ScheduledTask> task);

ScheduledTask runDelayed(Plugin plugin, Location location, Consumer<ScheduledTask> task,long delayTicks);

ScheduledTask runAtFixedRate(Plugin plugin, Location location, Consumer<ScheduledTask> task, long initialDelayTicks, long periodTicks);                               
```

依次是`runTask`、`runTaskLater`、`runTaskTimer` ， 参数... Plugin  插件实例， Location 调度程序调用的位置 剩下的和Bukkit一样， 不讲了捏。

`Consumer<ScheduledTask> task`表示一个方法/接口，需要传入一个`ScheduledTask`参数并无返回值的方法。 写法就很多了嘛：

```java
Bukkit.getRegionScheduler().run(instance, Location, new Consumer<ScheduledTask>() {
  					//some field
            @Override
            public void accept(ScheduledTask scheduledTask) {
                //code
            }
});
//lambda
Bukkit.getAsyncScheduler().runNow(instance,scheduledTask -> {
    //code
});
Bukkit.getRegionScheduler().run(XgpLottery.instance, player.getLocation(), scheduledTask -> Class.methed()));

```

`scheduledTask`相当于一个形参，实际上你想写成啥写成啥。

此处会返回一个`ScheduledTask`对象，作为调度程序的实例。 有这样的方法：

```java
 Plugin getOwningPlugin();  //获得插件实例
 boolean isRepeatingTask();  //是否是周期性的 , 例如上方的runAtFixedRate
 CancelledState cancel();   //尝试取消调度程序,返回尝试取消的结果。
 ExecutionState getExecutionState();  //返回当前任务的执行状态
 boolean isCancelled();  //.... 
```

在Bukkit中，我习惯于用`int taskId`来存放调度id， 然后使用·cancelTask(int taskId)·来取消， 而在F、olia中我们可以通过这样保存调度进程的对象来取消。

### EntityScheduler

实体的传送，在Bukkit中实体会有消失的状态，而Folia的多线程导致原版的实现方式并不安全。这个类提供了一个安全的方法来实现。同时还允许传入回调方法，即如果任务调度时实体已被删除，则调用回调方法。回调方法是完全线程安全的，同时你也可以通过前文所提的获得任务执行状态，来判断回调函数是否有执行。

```java
ScheduledTask run(Plugin plugin, Consumer<ScheduledTask> task,Runnable retired);

ScheduledTask runDelayed(Plugin plugin,Consumer<ScheduledTask> task,Runnable retired, long delayTicks);

ScheduledTask runAtFixedRate(Plugin plugin, Consumer<ScheduledTask> task,Runnable retired, long initialDelayTicks, long periodTicks);
                                       
```

不希望传入回调的代码就填入`null`就行。

### GlobalRegionScheduler

该任务调度程序可用于调度将在全局区域上执行的任务。例如负责维护世界白天时间、世界游戏时间、天气周期、睡眠跳过夜晚、执行控制台命令以及其他杂项。不属于任何特定区域的任务。 虽然是写的是全局，不要进行例如注册监听器、命令处理器的操作。 不管用的,你要用`AsyncScheduler`。

方法和上面的很像，不列出来了。 这个调度是操作/接受不了实体、方块等数据的。

这个接口提供的方法有`void cancelTasks(@NotNull Plugin plugin)` 取消插件的所有调度任务。

### AsyncScheduler

这玩意叫异步，可这个服务端没有主线程，叫异步任务我更觉得是并行。 当你不知道用什么调度任务的时候，如果前三个都没有提及，你应该尝试使用这个。

也提供了`void cancelTasks(@NotNull Plugin plugin)` 取消插件的所有调度任务。

这里有一个奇怪的参数`TimeUnit`，我不太理解为什么这个地方不统一用tick...

`TimeUnit`是一个枚举类

```java
    NANOSECONDS(TimeUnit.NANO_SCALE),     //纳秒
    MICROSECONDS(TimeUnit.MICRO_SCALE),  //微秒
    MILLISECONDS(TimeUnit.MILLI_SCALE), //毫秒
    SECONDS(TimeUnit.SECOND_SCALE),   ///秒
    MINUTES(TimeUnit.MINUTE_SCALE), //分
    HOURS(TimeUnit.HOUR_SCALE), //时
    DAYS(TimeUnit.DAY_SCALE); //日
```

由于1s = 20tick ， 原版1t = 50 TimeUnit.MILLISECONDS(毫秒) 在调度程序中`delay` `period` 如果像以前一样传入1t的话， 就得填50， 然后传入`TimeUnit.MILLISECONDS`。



### 注意事项&部分案例

一般来说调度的选择遵循这样的规则：

有关玩家、实体执行命令使用对应的 `RegionScheduler` 或者`EntityScheduler` ，控制台命令使用 `GlobalRegionScheduler`。

涉及单个实体的的操作，使用`EntityScheduler`，例如传送、对实体造成伤害。

---

比如我测试的调度： 做一个点击方块后获取玩家聊天输入的部分时候，即例如以下的代码使用调度添加：

```java
Listener listener =new Listener(player.getUniqueId(),future,time);
Bukkit.getPluginManager().registerEvents(listener,instance);
```

同时测试:

`AsyncScheduler` 成功

`GlobalRegionScheduler` `EntityScheduler`  与`RegionScheduler`无效，与前文分析略有印证。

---

还记得我前面说的

Folia的`RegionScheduler`和`EntityScheduler`允许将任务调度到“拥有”该特定位置或实体的区域的“下一个tick”。

在使用对应的(RunTaskTimer)的时候 这两个有一个delay参数， 延迟delay必须大于零。

否则会报错误 233

`java.lang.IllegalArgumentException: Initial delay ticks may not be <= 0`



控制台执行命令

```java
Bukkit.getGlobalRegionScheduler().run(XgpLottery.instance, scheduledTask -> getServer().dispatchCommand(getServer().getConsoleSender(), cmd));            
```

